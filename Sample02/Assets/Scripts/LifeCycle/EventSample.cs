using UnityEngine;
// This script is a simple Unity MonoBehaviour that serves as a template for creating event-driven functionality.
// 유니티에서는 스크립트의 실행, 활성화, 프레임 당 호출 등을 관리하기 위해 MonoBehaviour 클래스를 상속받습니다.

// Tip) 프로그래밍에서 함수는 특정 하나의 기능을 수행하기 위해서 명령문들을 모아놓은 명령 집합입니다.

public class EventSample : MonoBehaviour
{
    private void Awake()
    {
        Debug.Log("[Awake]");
        Debug.Log("씬이 시작될 때 호출됩니다. 초기화 작업을 여기에 작성하세요.");
        Debug.Log("해당 스크립트가 비활성화되어 있어도 이 위치의 작업은 실행됩니다.");
        Debug.Log("해당 영역에서 코루틴으로 실행이 불가능합니다.");
        // Coroutine: 코루틴은 유니티에서 비동기적으로 실행되는 함수로, 특정 시간 동안 대기하거나 반복 작업을 수행할 수 있습니다.
        Debug.Log("각 스크립트 기준 한 번만 호출이 되고 다른 개체의 초기화가 완료된 후 호출되는 영역이기 때문에 다른 컴포넌트에 대한 참조를 만들어야 하는 경우 이 위치에서 만들면 안전하게 처리됩니다.");
    }

    void OnEnable()
    {
        Debug.Log("[OnEnable]");
        Debug.Log("해당 스크립트가 활성화될 때 호출됩니다.");
        Debug.Log("이벤트 리스너를 등록하거나 초기화 작업을 수행하는 데 적합합니다.");
        Debug.Log("해당 영역에서 코루틴으로 실행이 불가능합니다.");
    }

    private void OnDisable()
    {
        
    }

    void Start()
    {
        Debug.Log("[Start]");
        Debug.Log("모든 스크립트의 Awake가 실행된 이후 실행되는 영역입니다.");
        Debug.Log("해당 영역에서는 코루틴을 실행할 수 있습니다.");
    }

    // Awake, Start의 공통점
    // 둘 다 기본적으로 값에 대한 초기화(할당)을 수행하는 위치입니다.
    // 어떤 것을 사용해도 상관은 없으나 상황에 따라 설계합니다.
    // Awake: 변수 초기화, 값 참조
    // Start: 컴포넌트 활성화, 게임 오브젝트 활성화, 씬 로딩, 게임 로직에 대한 실행, 초기화된 데이터를 기반으로 작업 수행, 코루틴 작업 등
    // 해당 상황에 대한 판단을 위해 Sample1, Sample2 파일을 통한 예시로 확인해봅시다.
    void Update()
    {
        // 화면에 렌더링되는 주기가 1초에 60번 정도로 호출되는 영역입니다. (하드웨어 사양에 따라 다를 수 있습니다.)

        // Time.deltaTime을 통해 프레임 간의 시간 차이를 보정 값으로 주거나 정규화/단위 벡터를 이용해 작업을 처리합니다.
        // 기본적으로 계산에 보정 값을 주지 않으면 프레임 레이트에 따라 결과가 달라질 수 있습니다.

        // 프로그램 내에서 핵심적으로 계속 사용되는 메인 로직을 작성하는 곳입니다.
        // ex) 플레이어 이동, 애니메이션 실행, 게임 오브젝트 상태 변경 등 (지속적인 업데이트 작업이 필요한 경우)

        // 업데이트를 대체할 수 있는 수단
        // 1. 상황에 맞는 유니티 생명 주기 함수 사용
        // 2. 코루틴
        // 3. 이벤트 시스템(버튼 클릭, 키 입력 등)
        // 4. C#의 가상 함수 개념(Update를 대신해 특정 클래스에서 업데이트 기능을 구현할 수 있습니다.)
        // 특정 하나의 관리 클래스(manager)에 Update의 로직을 위임해 관리해서 사용

        // 업데이트는 써야하는 기능이고 가장 많이 사용되는 영역입니다.
        // 따라서 업데이트에서 무조건 실행되어야 하는 상황이 아니라면 다른 영역에서 작업을 하게 설계하는 것이 업데이트의 부담을 줄여줄 수 있고 이게 성능의 향상으로 이어집니다.
        // -> 업데이트의 사용을 피하면 피할수록 성능은 향상됩니다.
    }

    private void FixedUpdate()
    {
        // 일정한 발생 주기가 보장되야 하는 로직에서 사용되는 영역입니다.
        // 물리 연산, 애니메이션, 타이머 등과 같이 일정한 시간 간격으로 실행되어야 하는 작업을 처리합니다.
        // 프레임을 기반으로 처리되는 것이 아닌 Fixed Timestep(고정 시간 간격)에 따라 호출됩니다.
        // 물리 연산(Rigidbody)이 적용된 오브젝트에 대한 조정

        // TimeScale이 0으로 설정된 경우 멈춥니다.
    }

    private void LateUpdate()
    {
        // 모든 업데이트가 끝난 후에 실행되는 영역입니다.
        // 주로 카메라의 위치를 플레이어의 위치에 맞춰서 조정하는 작업을 수행합니다.
        // 업데이트에서 처리한 결과를 기반으로 추가적인 작업을 수행할 때 사용합니다. (후처리 작업)
    }
}
