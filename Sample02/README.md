# 🎮 유니티 스크립트 예제  
UnityBootCamp14 Projects

---

## 📘 유니티의 생명주기

> 유니티에서는 프로그램의 실행부터 종료까지의 작업 영역을 함수로 제공합니다.  
> MonoBehaviour의 여러 생명주기 함수를 통해 객체의 초기화, 활성화, 비활성화, 프레임별 업데이트 등을 관리할 수 있습니다.

---

## 🔹 Awake

> * 씬이 시작될 때 호출됩니다. 초기화 작업을 여기에 작성하세요.  
> * 해당 스크립트가 비활성화되어 있어도 이 위치의 작업은 실행됩니다.  
> * 해당 영역에서 **코루틴 실행이 불가능**합니다.  
> * 각 스크립트 기준 한 번만 호출되며, **다른 컴포넌트의 초기화가 완료된 후** 호출되기 때문에,  
>   다른 컴포넌트에 대한 **안전한 참조를 생성**할 수 있는 위치입니다.

---

## 🔹 OnEnable

> * 해당 스크립트가 **활성화될 때마다** 호출됩니다.  
> * 이벤트 리스너를 등록하거나 초기화 작업을 수행하는 데 적합합니다.  
> * 해당 영역에서 **코루틴 실행이 불가능**합니다.  

---

## 🔹 Start

> * 모든 스크립트의 `Awake()`가 실행된 이후 호출됩니다.  
> * 해당 영역에서는 **코루틴 실행이 가능합니다**.  
> * 게임 로직 초기화, 씬 준비, 코루틴 시작 등의 작업에 사용됩니다.

---

## 🔹 Update

> * 매 프레임마다 호출됩니다. (보통 1초에 60번, 하드웨어에 따라 다름)  
> * `Time.deltaTime`을 통해 프레임 간 시간 차이를 보정하여  
>   정규화 벡터 등을 사용한 작업이 가능합니다.  

**사용 예시:**  
> * 플레이어 이동 처리  
> * 애니메이션 상태 변화 감지  
> * 오브젝트의 상태 변화 관리 등  

**성능 주의:**  
> * `Update()`는 가장 많이 호출되는 함수인 만큼,  
>   꼭 필요한 작업만 수행하고 가급적 사용을 최소화하는 것이 좋습니다.  

**대체 방법:**  
> 1. Unity의 다른 생명주기 함수 (`FixedUpdate`, `LateUpdate`, `OnTriggerXXX`, 등)  
> 2. Coroutine (`IEnumerator`)  
> 3. 이벤트 시스템 (UI 버튼 클릭, 키 입력 등)  
> 4. Manager 클래스에서 Update 로직 위임 (C#의 가상 함수 구조 활용)

---

## 🔹 FixedUpdate

> * 일정한 **시간 간격(고정 시간)**으로 호출됩니다.  
> * 주로 **물리 연산**, 애니메이션 타이밍, 타이머 처리 등에 사용됩니다.  
> * `Fixed Timestep` 설정에 따라 정확한 주기가 보장됩니다.  
> * `Time.timeScale = 0`이면 정지됩니다.  

---

## 🔹 LateUpdate

> * 모든 `Update()`가 끝난 뒤 호출됩니다.  
> * 주로 **후처리 작업**에 사용됩니다.  

**사용 예시:**  
> * 카메라가 플레이어를 따라가는 위치 조정  
> * 업데이트 결과 기반의 정렬, 위치 보정 등

---

## 🔄 Awake vs Start 정리

| 항목             | `Awake()`                          | `Start()`                          |
|------------------|------------------------------------|-------------------------------------|
| 호출 시점         | 컴포넌트가 로드될 때                | 모든 `Awake()` 실행 후              |
| 코루틴 사용 여부  | ❌ 사용 불가                        | ✅ 사용 가능                        |
| 주요 목적         | 변수 초기화, 참조 연결              | 게임 로직 시작, 씬 준비, 코루틴 실행 등 |

---

## 🧠 업데이트 함수 최적화 팁

> `Update()`는 강력하지만 성능 부담이 큽니다.  
> 반복적인 처리가 필요 없는 작업은 다른 구조로 대체하거나,  
> Manager 클래스나 Coroutine, 이벤트 기반 처리로 위임하는 것이 좋습니다.  
>  
> 💡 업데이트 사용을 줄이면 게임의 전반적인 퍼포먼스가 개선됩니다.

---

## 📎 참고

- 본 예제는 Unity 학습용이며, Unity의 MonoBehaviour 구조를 이해하는 데 목적이 있습니다.

---

## 🧑‍🏫 제작

- UnityBootCamp14 실습 자료  
- Instructor: *(당신의 이름을 여기에 입력하세요)*  
